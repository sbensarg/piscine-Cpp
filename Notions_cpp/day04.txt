Day 04

Sub-typing polymorphism:

Resolution statique de l’appel de fonction , c’est a dire qu’a la compilation je suis deja quelle est la fonction que je vais appeler. 

Class Character
{
	public:
		void sayHello(std::string const & target);
};

Class Warrior
{
	public:
		void sayHello(std::string const & target);
};

void Character::sayHello(std::string const & target)
{
	std::cout << “hi” << target;
}

void Warrior::sayHello(std::string const & target)
{
	std::cout << “hello” << target
}

Warrior* a = new Warrior();
Character* b = new Warrior();
A->sayHello(“Sara”);
b->sayHello(“Sara”);

//————————————————————//

Class Character
{
	public:
		virtual void sayHello(std::string const & target);
};

Class Warrior
{
	public:
		virtual void sayHello(std::string const & target);
};

void Character::sayHello(std::string const & target)
{
	std::cout << “hi” << target;
}
 (
void Warrior::sayHello(std::string const & target)
{
	std::cout << “hello” << target
}

Grace a virtual la resolution de l’apple de functions va devenir dynamique elle va être faite a l’execution (utilisation de comportement de type reel).
méthode : c’est une fonction membre dont la resolution va être dynamique.
Function membre virtuel == méthode 

Abstract classes and interfaces

methode pure
example
class ACharacter
{
   public: 
   	virtual void attack(std::string const & target) = 0; // methode pure : les consequences de cette methode (1. la methode on ne peut pas l'implementer, 2.la classe on ne va pas pouvoir l'instancier), elle va donc devenir abstraite.
};
- A class is made abstract by declaring at least one of its functions as pure virtual function. A pure virtual function is specified by placing "= 0" in its declaration.
- An interface class contains only a virtual destructor and pure virtual functions.

Shallow Copy and Deep Copy

In general, if the variables of an object have been dynamically allocated then it is required to do a Deep Copy in order to create a copy of the object.

in shallow copy constructor. Both objects will point to same memory location.

Deep copy allocates separate memory for copied information. So the source and copy are different. Any changes made in one memory location will not affect copy in the other location. When we allocate dynamic memory using pointers we need user defined copy constructor. Both objects will point to different memory locations.








